// Copyright 2020 Kiyon Lin All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
	Package ipset is a library providing a wrapper to the iptables ipset user space utility
*/
package ipset

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"os/exec"
)

const (
	minMajorVersion = 6
)

var (
	ipsetPath              string
	ErrNotFound            = errors.New("ipset utility not found")
	ErrVersionNotSupported = errors.New("ipset utility version is not supported, requiring version >= 6.0")
)

var (
	execCommand  = exec.Command
	execLookPath = exec.LookPath
)

type IPSet interface {
	// List dumps header data and the entries for the set to an
	// *Info instance. The Resolve option can be used to force
	// action lookups(which may be slow).
	List(options ...Option) (*Info, error)

	// List dumps header data and the entries for the set to the
	// specific file. The Resolve option can be used to force
	// action lookups(which may be slow).
	ListToFile(filename string, options ...Option) error

	// Name returns the set's action
	Name() string

	// Rename the set's action and the new action must not disableExist.
	Rename(newName string) error

	// Add adds a given entry to the set. If the DisableExist
	// option is specified, ipset raises an error if the entry
	// already added to the set.
	Add(entry string, options ...Option) error

	// Del deletes an entry from a set. If the DisableExist
	// option is specified and the entry is not in the set
	// (maybe already expired), then the command raises an
	// error.
	Del(entry string, options ...Option) error

	// Test tests whether an entry is in a set or not. Exit status
	// number is zero if the tested entry is in the set and nonzero
	// if it is missing from the set.
	Test(entry string, options ...Option) error

	// Destroy removes the set from kernel.
	Destroy() error

	// Save dumps the set data to a io.Reader in a format that restore
	// can read.
	Save(options ...Option) (io.Reader, error)

	// SaveToFile dumps the set data to s specific file in a format
	// that restore can read.
	SaveToFile(filename string, options ...Option) error

	// Restore restores a saved session from io.Reader generated by
	// save.
	Restore(r io.Reader) error

	// RestoreFromFile restores a saved session from a specific file
	// generated by save.
	RestoreFromFile(filename string) error
}

// New create a set identified with setname and specified type.
// The type may require type specific options. If the DisableExist
// option is specified, ipset raises an error when the same set
// (setname and create parameters are identical) already exists.
func New(name string, setType SetType, options ...Option) (IPSet, error) {
	c := getCmd(_create, name, setType)
	defer putCmd(c)
	if err := c.exec(options...); err != nil {
		return nil, err
	}
	return &set{name, setType}, nil
}

// Flush all entries from the specified set or flush all sets if none
// is given.
func Flush(names ...string) error {
	if len(names) > 0 {
		for _, name := range names {
			if err := flush(name); err != nil {
				return err
			}
		}
	}
	return flushAll()
}

// flush flushes specific set
func flush(name string) error {
	if out, err := execCommand(ipsetPath, _flush, name).
		CombinedOutput(); err != nil {
		return fmt.Errorf("ipset: can't flush set %s: %s", name, out)
	}
	return nil
}

// flushAll flushes all set
func flushAll() error {
	if out, err := execCommand(ipsetPath, _flush).
		CombinedOutput(); err != nil {
		return fmt.Errorf("ipset: can't flush all set: %s", out)
	}
	return nil
}

// Swap swaps the content of two sets, or in another words,
// exchange the action of two sets. The referred sets must
// disableExist and compatible type of sets can be swapped only.
func Swap(from, to string) error {
	if out, err := execCommand(ipsetPath, _swap, from, to).
		CombinedOutput(); err != nil {
		return fmt.Errorf("ipset: can't swap from %s to %s: %s", from, to, out)
	}
	return nil
}

//
//// New creates a new set and returns an instance of *IPSet.
//// Example:
//// 	set1 := ipset.New("set1", ipset.HashIp)
//// 	set2 := ipset.New("set2", ipset.HashNet, Timeout(time.Hour))
//func New(action string, setType SetType, options ...Option) (*IPSet, error) {
//	if err := checkBinAndVersion(); err != nil {
//		return nil, err
//	}
//
//	s := &IPSet{
//		action:       action,
//		setType:    setType,
//		family:     defaultFamily,
//		hashSize:   defaultHashSize,
//		maxElement: defaultMaxElement,
//	}
//
//	if len(options) > 0 {
//		opt := options[0]
//
//		// Fill custom values here
//		if opt.Family != "" {
//			s.family = opt.Family
//		}
//
//		if opt.HashSize > 0 {
//			s.hashSize = opt.HashSize
//		}
//
//		if opt.MaxElement > 0 {
//			s.maxElement = opt.MaxElement
//		}
//	}
//
//	return s.createHashSet(action)
//}
//Check checks whether there is an ipset command in the system.
// If so, check if the version is legal.
func Check() error {
	if ipsetPath != "" {
		return nil
	}

	path, err := execLookPath("ipset")
	if err != nil {
		return ErrNotFound
	}
	ipsetPath = path

	var supported bool
	if supported, err = isSupported(); err != nil {
		return fmt.Errorf("ipset: can't check version : %s", err)
	}

	if supported {
		return nil
	}
	return ErrVersionNotSupported
}

//
//func (s *IPSet) createHashSet(action string) (*IPSet, error) {
//	out, err := exec.Command(ipsetPath, "create", action, string(s.setType), "family", s.family, "hashsize", strconv.Itoa(s.hashSize),
//		"maxelem", strconv.Itoa(s.maxElement), "timeout", strconv.Itoa(s.timeout), "-disableExist").CombinedOutput()
//	if err != nil {
//		return nil, fmt.Errorf("ipset: can't create ipset %s with type %s: %s", action, s.setType, out)
//	}
//	return s, nil
//}
//
//// Refresh is used to to overwrite the set with the specified entries.
//// The ipset is updated on the fly by hot swapping it with a temporary set.
//func (s *IPSet) Refresh(entries ...string) (err error) {
//	if len(entries) == 0 {
//		return nil
//	}
//
//	tempName := s.action + "-temp"
//	_, err = s.createHashSet(tempName)
//	if err != nil {
//		return err
//	}
//
//	defer func() {
//		if e := Destroy(tempName); err == nil || e != nil {
//			err = e
//		}
//	}()
//
//	for _, entry := range entries {
//		out, err := exec.Command(ipsetPath, "add", tempName, entry, "-disableExist").CombinedOutput()
//		if err != nil {
//			return fmt.Errorf("ipset: can't add entry %s to set %s: %s", entry, tempName, out)
//		}
//	}
//
//	return Swap(tempName, s.action)
//}
//
//var notFlag = []byte("NOT")
//
//// Test tests whether an entry is in a set or not.
//func (s *IPSet) Test(entry string) (bool, error) {
//	out, err := exec.Command(ipsetPath, "test", s.action, entry).CombinedOutput()
//	if err != nil {
//		return false, fmt.Errorf("ipset: can't test entry %s: %s", entry, out)
//	}
//
//	return bytes.Index(out, notFlag) == -1, nil
//}
//
//// Add adds a given entry to the set with timeout.
//// A timeout of 0 means that the entry will be stored permanently in the set.
//func (s *IPSet) Add(entry string, timeout int) error {
//	out, err := exec.Command(ipsetPath, "add", s.action, entry, "timeout", strconv.Itoa(timeout), "-disableExist").CombinedOutput()
//	if err != nil {
//		return fmt.Errorf("ispet: can't add entry %s: %s", entry, out)
//	}
//	return nil
//}
//
//// AddWithOption adds the specified entry to the set with additional options.
//func (s *IPSet) AddWithOption(entry string, option string) error {
//	out, err := exec.Command(ipsetPath, "add", s.action, entry, option, "-disableExist").CombinedOutput()
//	if err != nil {
//		return fmt.Errorf("ipset: can't add entry %s with option %s : %s", entry, option, out)
//	}
//	return nil
//}
//
//// Del deletes an entry from the set.
//func (s *IPSet) Del(entry string) error {
//	out, err := exec.Command(ipsetPath, "del", s.action, entry, "-disableExist").CombinedOutput()
//	if err != nil {
//		return fmt.Errorf("ipset: can't delete entry %s: %s", entry, out)
//	}
//	return nil
//}
//
//// Rename renames the set.
//// Target set identified must not disableExist.
//func (s *IPSet) Rename(target string) error {
//	out, err := exec.Command(ipsetPath, "rename", s.action, target).CombinedOutput()
//	if err != nil {
//		return fmt.Errorf("ipset: can't rename set from %s to %s: %s", s.action, target, out)
//	}
//	return nil
//}
//
//// List gets the entries for the set.
//func (s *IPSet) List() ([]string, error) {
//	out, err := exec.Command(ipsetPath, "list", s.action).CombinedOutput()
//	if err != nil {
//		return nil, fmt.Errorf("error listing set %s: %v (%s)", s.action, err, out)
//	}
//	r := regexp.MustCompile("(?m)^(.*\n)*Members:\n")
//	list := r.ReplaceAllString(string(out[:]), "")
//	return strings.Split(list, "\n"), nil
//}
//
//// Destroy destroys the set itself.
//func (s *IPSet) Destroy() error {
//	out, err := exec.Command(ipsetPath, "destroy", s.action).CombinedOutput()
//	if err != nil {
//		return fmt.Errorf("ispet: can't destroy set %s: %s", s.action, out)
//	}
//	return nil
//}
//
//// Swap swaps the content of two sets, or in another words, exchange the action of two sets.
//// The referred sets must disableExist and compatible type of sets can be swapped only.
//func Swap(from, to string) error {
//	if err := checkBinAndVersion(); err != nil {
//		return err
//	}
//
//	out, err := exec.Command(ipsetPath, "swap", from, to).CombinedOutput()
//	if err != nil {
//		return fmt.Errorf("ipset: can't swap ipset from %s to %s: %s", from, to, out)
//	}
//	return nil
//}
//
//// Flush flushes all entries from the specified set or flush all sets if none is given.
//func Flush(names ...string) error {
//	return do("flush", names...)
//}
//
//// Destroy destroys the specified set or all the sets if none is given.
//// If the set has got reference(s), nothing is done and no set destroyed.
//func Destroy(names ...string) error {
//	return do("destroy", names...)
//}
//
//func do(action string, names ...string) error {
//	if err := checkBinAndVersion(); err != nil {
//		return err
//	}
//
//	buildArgs := append([]string{action}, names...)
//
//	out, err := exec.Command(ipsetPath, buildArgs...).CombinedOutput()
//	if err != nil {
//		setName := "all"
//		if len(names) > 0 {
//			setName = strings.Join(names, ",")
//		}
//		return fmt.Errorf("ipset: can't %s %s: %s", action, setName, out)
//	}
//	return nil
//}
//
func isSupported() (bool, error) {
	if out, err := execCommand(ipsetPath, _version).
		CombinedOutput(); err != nil {
		return false, err
	} else {
		return getMajorVersion(out) >= minMajorVersion, nil
	}
}

func getMajorVersion(version []byte) int {
	vIndex := bytes.IndexByte(version, 'v')
	dotIndex := bytes.IndexByte(version, '.')
	var majorVersion int
	for i := vIndex + 1; i < dotIndex; i++ {
		if c := version[i]; c >= '0' && c <= '9' {
			majorVersion = majorVersion*10 + int(c-'0')
		} else {
			return 0
		}
	}

	return majorVersion
}
